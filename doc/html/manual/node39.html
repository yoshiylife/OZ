<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 95 (Thu Jan 19 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >
<!Actually with its Japanized version JLaTeX2HTML 95 (Wed Mar 1 1995) by Masahiro Kitagawa (kitagawa@ee.es.osaka-u.ac.jp), Osaka University >
<HEAD>
<TITLE>5.19 Concurrent Programming</TITLE>
</HEAD>
<BODY>
<meta name="description" value="5.19 Concurrent Programming">
<meta name="keywords" value="main">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
 <H2><A NAME=SECTION000619000000000000000>5.19 Concurrent Programming</A></H2>
 <A NAME=langlangmanualconcurrent>&#160;</A>
<P>
This section describes concurrent programming features of OZ++ language.
<P>
OZ++ is an object-oriented system where the message is sent to the object 
and the responding method is executed.  
At this time, a multiple method to one object is enabled to execute.
<P>
The following features are provided as language elements 
for supporting concurrent programming 
in OZ++ are provided:
<P>
<OL><LI>  Method attribute concerned with exclusive control (see Section <A HREF="node33.html#langlangmanualclassmember">5.13.2</A>)
<P>
<LI>  Process derived type and its operation 
(see Section <A HREF="node28.html#langlangmanualprocess">5.8</A>)
<P>
<LI>  <tt> Condition</tt> type as a standard type describing the 
<tt> condition</tt> variable for synchronizing processes and its operation.
</OL>
<P>
Feature 1 is an attribute of method that controls whether or not it gets 
the lock before invocation for exclusive control of the method of 
the ordinary class and statistic class.  
With this attribute, the instance generated by the class automatically 
becomes a monitor, and then it becomes unnecessary to program exclusive control
by users.
However, nesting of a monitor is not allowed, so it is necessary to pay 
attention to programming, because the deadlock occurs when the method 
requiring lock of an object is invoked within the invocation chain from 
the method requiring lock of the same object.
Program shown below is an example which causes deadlock.
<P>
<PRE>class A {
  public: m0;

  void m0(B b) 
    {
      b-&gt;m1(self);
    }
}

class B {
  public: m1;

  int m1(A a) : locked 
    {
      a-&gt;m0(self); 	
       // It is dangerous to send the object of a monitor
       // in the method gaining the lock.
    }
}

B b;
A a;

b=&gt;new();
a=&gt;new();
b-&gt;m1(a);               // deadlock
</PRE>
<P>
Feature 2 enables concurrent programming on the macro level of 
so-called process which is the chain of method activation of the thread.
Furthermore, the process generation is controlled by the user.
<P>
Feature 3 supports synchronized control among multiple processes executed 
concurrently.  
OZ++ requests that the object requiring synchronized control is a monitor,
so methods should have a <tt> locked</tt> attribute.
<P>
OZ++ provides flexible concurrent programming when the user uses these 
three language features appropriately in response to the description 
level of the concurrent operation requested.
<P>
<H3><A NAME=SECTION000619100000000000000>5.19.1  Condition Type</A></H3>
 <A NAME=langlangmanualconcurrentcondition>&#160;</A>
<P>
<tt> Condition</tt> type is a basic type which represents the condition variable 
controlling synchronization among processes of concurrent execution 
(see Chapter <A HREF="node24.html#langlangmanualdatatype">5.4</A>).  
This type consumes a certain sized memory area determined 
by the implementation of an executor.
<P>
The operates to the <tt> condition</tt> type is as follows:
<P>
<UL><LI> <tt> wait</tt>
<LI> <tt> signal</tt>
<LI> <tt> signalall</tt>
</UL>
<P>
Furthermore, the method for executing these operations must have 
a <tt> locked</tt> attribute.
<P>
<tt> Wait</tt> <BR>
<P>
When this operation is executed to the condition variable, 
the following processes are performed:
<P>
<OL><LI>  This command releases the monitor lock, and enters into the queue 
of the execution of condition variable.
<LI>  When other processes <tt> signal</tt> the condition variable, 
this command may be put out of the queue and the execution may be resumed.
(Only one waiting process is signaled by the <tt> signal</tt> of other process and
all waiting processes are signaed by the <tt> signalall</tt> of other process.)
<LI>  This process tries to get the monitor lock again.
</OL>
<P>
In this way, the control may not to pass to the process <tt> wait</tt>ed immediately 
by this <tt> signal</tt>, so <tt> wait</tt> needs to be enclosed in a loop.
<P>
For example, the process which waits until buffer becomes empty 
should not be programmed as follows:
<P>
<PRE>condition c;

if (buffer is empty)
  {
    wait c;
  }
</PRE>
<P>
but be programmed as follows;
<P>
<PRE>condition c;

while (buffer is empty)
  {
    wait c;
  }
</PRE>
<P>
<tt> signal</tt> <BR>
<P>
The execution of the process at the top of the queue waiting for the condition 
variable is resumed.  
If the queue is empty, there has no side effect.
<P>
<tt> signalall</tt> <BR>
<P>
The execution of all the processes of the queue waiting for the condition 
variable is resumed.  
If the queue is empty, there is no side effect.
<P>
<H3><A NAME=SECTION000619200000000000000>5.19.2 An example of concurrent Program</A></H3>
<P>
<PRE>class Pen {
  public: Draw;

  // This is a global method for writing character
  // strings on a white board.
  void Draw(WhiteBoard wb, String str) : global 
    {
      ...
      wb-&gt;Draw(str);
      ...
    }
  ...
};

// List &lt;Item&gt; is assigned as a parent to manage 
// what are written (Item) on a white board.
class WhiteBoard : List&lt;Item&gt; {
  public: Draw;

  Pen aPen;

  // This is a method for indicating character 
  // strings on a white board.
  void Draw(String str)
    {
      ...
    }
  ...
};

// This is a class indicating a co-owned white board.
class SharedWhiteBoard : 
  WhiteBoard (
    // Method Draw inherited from WhiteBoard is
    // renamed WDraw.
    rename Draw WDraw;
  ) {

  public: GetBlack, GetRed, PutBlack, PutRed, Draw;
	
  // The flag indicates what Pen is used.
  int BlackInUse, RedInUse;

  // This is a condition variable to be synchronized
  // when Pen use is finished.
  condition BlackIsFree, RedIsFree;

  Pen Black, Red;

  // This is a method for taking a Pen to use it.
  Pen GetBlack() : locked, global 
    {
      while (BlackInUse) 
        wait BlackIsFree;
      BlackInUse = 1;
      return Black;
    }

  // The definition of GetRed is omitted.
 
  // This is a method for returning a used Pen.
  void PutBlack() : locked, global 
    {
      BlackInUse = 0;
      signal BlackIsFree;
    }

  // The definition of PutRed is omitted.

  // This is a method for indicating character
  // strings on a co-owned white board.
  void Draw(String str)
    {
      ...
      WDraw(str);
      ...
    }
  ...
};
</PRE>
<P>
This example shows a co-owned white board (class <tt> SharedWhiteBoard</tt>) with two pens (<tt> Black</tt> and <tt> Red</tt>).
<P>
The process to write character strings on this co-owned white board 
is performed as follows:
<P>
<OL><LI>  First, the pen of required color is obtained 
(by executing the method <tt> GetBlack()</tt> or <tt> GetRed()</tt>).
<P>
<LI>  Character strings are written 
(by executing the class <tt> Pen</tt>'s method <tt> Draw()</tt> 
to the object of pens which are gotten) by the pens.
<P>
<LI>  Used pens are released 
(by executing the method <tt> PutBlack()</tt> or <tt> PutRed()</tt>).
<P>
</OL>
<P>
In this process, the exclusive control is necessary for the process 
of obtaining and returning pens, so <tt> locked</tt> is specified to these methods.  
Furthermore, synchronization is realized by using condition variables 
(<tt> BlackFree</tt> and <tt> RedFree</tt>) because it is necessary to synchronize 
between the obtaining and releasing of a pen.
<P>

<P>

<P>
<BR> <HR>
<P><ADDRESS>
Copyright 1994-1997 Information-technology Promotion Agency, Japan
</ADDRESS>
</BODY>
